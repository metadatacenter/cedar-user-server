package controllers;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.node.JsonNodeFactory;
import com.fasterxml.jackson.databind.node.ObjectNode;
import org.keycloak.representations.AccessToken;
import org.metadatacenter.config.CedarConfig;
import org.metadatacenter.constant.HttpConstants;
import org.metadatacenter.server.security.Authorization;
import org.metadatacenter.server.security.CedarAuthFromRequestFactory;
import org.metadatacenter.server.security.CedarUserRolePermissionUtil;
import org.metadatacenter.server.security.KeycloakUtils;
import org.metadatacenter.server.security.exception.CedarUserNotFoundException;
import org.metadatacenter.server.security.exception.InvalidOfflineAccessTokenException;
import org.metadatacenter.server.security.model.IAuthRequest;
import org.metadatacenter.server.security.model.auth.AuthorisedUser;
import org.metadatacenter.server.security.model.auth.CedarPermission;
import org.metadatacenter.server.security.model.user.CedarUser;
import org.metadatacenter.server.security.model.user.CedarUserExtract;
import org.metadatacenter.server.security.util.CedarUserUtil;
import org.metadatacenter.server.service.UserService;
import org.metadatacenter.util.CedarUserNameUtil;
import org.metadatacenter.util.json.JsonMapper;
import org.metadatacenter.util.mongo.MongoUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import play.mvc.Result;
import utils.DataServices;

import java.io.IOException;
import java.rmi.AccessException;

public class UserServerController extends AbstractUserServerController {
  private static Logger log = LoggerFactory.getLogger(UserServerController.class);

  private static UserService userService;

  public static void injectUserService(UserService us) {
    userService = us;
  }

  public static Result createUser() {
    try {
      IAuthRequest authRequest = CedarAuthFromRequestFactory.fromRequest(request());

      AccessToken accessToken = null;
      try {
        accessToken = KeycloakUtils.parseToken(authRequest.getAuthString(), AccessToken.class);
      } catch (IOException e) {
        throw new InvalidOfflineAccessTokenException();
      }
      AuthorisedUser userFromToken = KeycloakUtils.getUserFromToken(accessToken);

      CedarConfig cedarConfig = DataServices.getCedarConfig();
      CedarUserExtract cue = new CedarUserExtract(userFromToken.getId(), userFromToken.getFirstName(), userFromToken
          .getLastName(), userFromToken.getEmail());
      CedarUser user = CedarUserUtil.createUserFromBlueprint(cue);

      CedarUser u = userService.createUser(user);
      CedarUserRolePermissionUtil.expandRolesIntoPermissions(u);

      JsonNode createdUser = JsonMapper.MAPPER.valueToTree(u);
      // Remove autogenerated _id field to avoid exposing it
      MongoUtils.removeIdField(createdUser);
      // Set Location header pointing to the newly created template
      String absoluteUrl = routes.UserServerController.findOwnUser(u.getId()).absoluteURL(request());
      response().setHeader(HttpConstants.HTTP_HEADER_LOCATION, absoluteUrl);
      // Return created response
      return created(createdUser);
    } catch (IllegalArgumentException e) {
      return badRequestWithError(e);
    } catch (AccessException e) {
      return forbiddenWithError(e);
    } catch (Exception e) {
      return internalServerErrorWithError(e);
    }
  }


  public static Result findOwnUser(String id) {
    try {
      IAuthRequest authRequest = CedarAuthFromRequestFactory.fromRequest(request());
      CedarUser currentUser = Authorization.getUserAndEnsurePermission(authRequest, CedarPermission
          .LOGGED_IN);

      if (!id.equals(currentUser.getId())) {
        ObjectNode errorParams = JsonNodeFactory.instance.objectNode();
        errorParams.put("currentUserId", currentUser.getId());
        errorParams.put("requestedUserId", id);
        return forbidden(generateErrorDescription("readOtherProfile",
            "You are not allowed to read other user's profile!", errorParams));
      }

      CedarUser u = userService.findUser(id);
      if (u != null) {
        CedarUserRolePermissionUtil.expandRolesIntoPermissions(u);
        JsonNode user = JsonMapper.MAPPER.valueToTree(u);
        // Remove autogenerated _id field to avoid exposing it
        MongoUtils.removeIdField(user);
        return ok(user);
      }
      return notFound();
    } catch (CedarUserNotFoundException e) {
      return notFound();
    } catch (IllegalArgumentException e) {
      return badRequestWithError(e);
    } catch (Exception e) {
      return internalServerErrorWithError(e);
    }
  }

  public static Result findUserSummary(String id) {
    try {
      IAuthRequest authRequest = CedarAuthFromRequestFactory.fromRequest(request());
      Authorization.getUserAndEnsurePermission(authRequest, CedarPermission.LOGGED_IN);

      CedarUser u = userService.findUser(id);
      if (u != null) {
        JsonNode user = JsonMapper.MAPPER.valueToTree(u);
        ObjectNode summary = JsonNodeFactory.instance.objectNode();
        summary.set("userId", user.get("id"));
        summary.set("screenName", JsonNodeFactory.instance.textNode(CedarUserNameUtil.getDisplayName(u)));
        return ok(summary);
      }
      return notFound();
    } catch (CedarUserNotFoundException e) {
      return notFound();
    } catch (IllegalArgumentException e) {
      return badRequestWithError(e);
    } catch (Exception e) {
      return internalServerErrorWithError(e);
    }
  }

  public static Result updateUser(String id) {
    try {
      IAuthRequest authRequest = CedarAuthFromRequestFactory.fromRequest(request());
      CedarUser currentUser = Authorization.getUserAndEnsurePermission(authRequest, CedarPermission.LOGGED_IN);

      if (!id.equals(currentUser.getId())) {
        ObjectNode errorParams = JsonNodeFactory.instance.objectNode();
        errorParams.put("currentUserId", currentUser.getId());
        errorParams.put("requestedUserId", id);
        return forbidden(generateErrorDescription("updateOtherProfile",
            "You are not allowed to update other user's profile!", errorParams));
      }

      JsonNode modifications = request().body().asJson();
      CedarUser u = userService.updateUser(id, modifications);

      CedarUserRolePermissionUtil.expandRolesIntoPermissions(u);

      JsonNode updatedUser = JsonMapper.MAPPER.valueToTree(u);
      // Remove autogenerated _id field to avoid exposing it
      MongoUtils.removeIdField(updatedUser);
      return ok(updatedUser);
    } catch (IllegalArgumentException e) {
      return badRequestWithError(e);
    } catch (AccessException e) {
      return forbiddenWithError(e);
    } catch (Exception e) {
      return internalServerErrorWithError(e);
    }
  }


}
